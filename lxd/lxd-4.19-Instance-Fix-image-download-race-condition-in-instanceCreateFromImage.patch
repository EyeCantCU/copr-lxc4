From a1a0f7ec667be66b833af90ffec0c83a87a1bf10 Mon Sep 17 00:00:00 2001
From: Thomas Parrott <thomas.parrott@canonical.com>
Date: Tue, 5 Oct 2021 14:14:13 +0100
Subject: [PATCH] lxd/instance: Fix image download race condition in
 instanceCreateFromImage

If multiple instances were launched on the same cluster member, using the same image, at the same time,
then it was possible for both to come to the conclusion that the image required didn't exist locally
and start the process of downloading it to the local member.

Unfortunately the lock that ensures this process doesn't happen concurrently was being taken too later,
when really we needed to ensure that the 2nd instance waited until the 1st instance has finished downloading
the image and adding it the local member's DB record before checking whether it is available.

Fixes #9326

Signed-off-by: Thomas Parrott <thomas.parrott@canonical.com>
---
 lxd/instance.go | 18 +++++++++++-------
 1 file changed, 11 insertions(+), 7 deletions(-)

diff --git a/lxd/instance.go b/lxd/instance.go
index 74a69ddbf85..ab93ed0296b 100644
--- a/lxd/instance.go
+++ b/lxd/instance.go
@@ -107,16 +107,20 @@ func instanceCreateFromImage(d *Daemon, r *http.Request, args db.InstanceArgs, h
 		return nil, fmt.Errorf("Requested image's type '%s' doesn't match instance type '%s'", imgType, args.Type)
 	}
 
-	// Check if the image is available locally or it's on another node.
+	// Check if the image is available locally or it's on another member.
+	// Ensure we are the only ones operating on this image. Otherwise another instance created at the same
+	// time may also arrive at the conclusion that the image doesn't exist on this cluster member and then
+	// think it needs to download the image and store the record in the database as well, which will lead to
+	// duplicate record errors.
+	unlock := d.imageDownloadLock(img.Fingerprint)
+
 	nodeAddress, err := s.Cluster.LocateImage(hash)
 	if err != nil {
+		unlock()
 		return nil, errors.Wrapf(err, "Locate image %q in the cluster", hash)
 	}
 
 	if nodeAddress != "" {
-		// Ensure we are the only ones operating on this image.
-		unlock := d.imageDownloadLock(img.Fingerprint)
-
 		// The image is available from another node, let's try to import it.
 		err = instanceImageTransfer(d, r, args.Project, img.Fingerprint, nodeAddress)
 		if err != nil {
@@ -128,12 +132,12 @@ func instanceCreateFromImage(d *Daemon, r *http.Request, args db.InstanceArgs, h
 		err = d.cluster.AddImageToLocalNode(args.Project, img.Fingerprint)
 		if err != nil {
 			unlock()
-			return nil, errors.Wrapf(err, "Failed adding transferred image %q to local cluster member", img.Fingerprint)
+			return nil, errors.Wrapf(err, "Failed adding transferred image %q record to local cluster member", img.Fingerprint)
 		}
-
-		unlock()
 	}
 
+	unlock() // Image is available locally.
+
 	// Set the "image.*" keys.
 	if img.Properties != nil {
 		for k, v := range img.Properties {
