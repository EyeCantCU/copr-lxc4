From c14fc56574dbb07bfda06db08f73cd41997fa391 Mon Sep 17 00:00:00 2001
From: Thomas Parrott <thomas.parrott@canonical.com>
Date: Mon, 7 Feb 2022 13:48:25 +0000
Subject: [PATCH] shared/util/linux: Add channel closed check before writing in
 ExecReaderToChannel

Fixes #9839

Signed-off-by: Thomas Parrott <thomas.parrott@canonical.com>
---
 shared/util_linux.go | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/shared/util_linux.go b/shared/util_linux.go
index 15d313a1968..0197cd12b68 100644
--- a/shared/util_linux.go
+++ b/shared/util_linux.go
@@ -5,6 +5,7 @@ package shared
 
 import (
 	"bufio"
+	"context"
 	"fmt"
 	"io"
 	"os"
@@ -12,7 +13,6 @@ import (
 	"path/filepath"
 	"reflect"
 	"strings"
-	"sync"
 	"sync/atomic"
 	"syscall"
 	"unsafe"
@@ -453,12 +453,7 @@ func ExecReaderToChannel(r io.Reader, bufferSize int, exited <-chan struct{}, fd
 
 	ch := make(chan ([]byte))
 
-	// Takes care that the closeChannel() function is exactly executed once.
-	// This allows us to avoid using a mutex.
-	var once sync.Once
-	closeChannel := func() {
-		close(ch)
-	}
+	channelCtx, channelCancel := context.WithCancel(context.Background())
 
 	// [1]: This function has just one job: Dealing with the case where we
 	// are running an interactive shell session where we put a process in
@@ -479,27 +474,25 @@ func ExecReaderToChannel(r io.Reader, bufferSize int, exited <-chan struct{}, fd
 
 		atomic.StoreInt32(&attachedChildIsDead, 1)
 
+		defer channelCancel()
+
 		ret, revents, err := GetPollRevents(fd, 0, (unix.POLLIN | unix.POLLPRI | unix.POLLERR | unix.POLLHUP | unix.POLLRDHUP | unix.POLLNVAL))
 		if ret < 0 {
 			logger.Errorf("Failed to poll(POLLIN | POLLPRI | POLLHUP | POLLRDHUP) on file descriptor: %s.", err)
 			// Something went wrong so let's exited otherwise we
 			// end up in an endless loop.
-			once.Do(closeChannel)
 		} else if ret > 0 {
 			if (revents & unix.POLLERR) > 0 {
 				logger.Warnf("Detected poll(POLLERR) event.")
 				// Read end has likely been closed so again,
 				// avoid an endless loop.
-				once.Do(closeChannel)
 			} else if (revents & unix.POLLNVAL) > 0 {
 				logger.Warnf("Detected poll(POLLNVAL) event.")
 				// Well, someone closed the fd havent they? So
 				// let's go home.
-				once.Do(closeChannel)
 			}
 		} else if ret == 0 {
 			logger.Debugf("No data in stdout: exiting.")
-			once.Do(closeChannel)
 		}
 	}()
 
@@ -509,7 +502,8 @@ func ExecReaderToChannel(r io.Reader, bufferSize int, exited <-chan struct{}, fd
 		buf := make([]byte, bufferSize)
 		avoidAtomicLoad := false
 
-		defer once.Do(closeChannel)
+		defer close(ch)
+		defer channelCancel()
 		for {
 			nr := 0
 			var err error
@@ -613,6 +607,12 @@ func ExecReaderToChannel(r io.Reader, bufferSize int, exited <-chan struct{}, fd
 				return
 			}
 
+			// Check if channel is closed before potentially writing to it below.
+			if channelCtx.Err() != nil {
+				logger.Debug("Detected closed channel: exiting")
+				return
+			}
+
 			offset += nr
 			if offset > 0 && (offset+readSize >= bufferSize || err != nil) {
 				ch <- buf[0:offset]
