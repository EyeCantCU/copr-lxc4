diff --git a/lxd/instance/drivers/driver_qemu.go b/lxd/instance/drivers/driver_qemu.go
index ad852b3a6..dd9d59c87 100644
--- a/lxd/instance/drivers/driver_qemu.go
+++ b/lxd/instance/drivers/driver_qemu.go
@@ -2884,17 +2884,11 @@ func (d *qemu) generateQemuConfigFile(mountInfo *storagePools.MountInfo, busName
 // addCPUMemoryConfig adds the qemu config required for setting the number of virtualised CPUs and memory.
 // If sb is nil then no config is written.
 func (d *qemu) addCPUMemoryConfig(cfg *[]cfgSection) error {
-	drivers := DriverStatuses()
-	info := drivers[instancetype.VM].Info
-	if info.Name == "" {
-		return fmt.Errorf("Unable to ascertain QEMU version")
-	}
-
 	// Figure out what memory object layout we're going to use.
 	// Before v6.0 or if version unknown, we use the "repeated" format, otherwise we use "indexed" format.
 	qemuMemObjectFormat := "repeated"
 	qemuVer6, _ := version.NewDottedVersion("6.0")
-	qemuVer, _ := version.NewDottedVersion(info.Version)
+	qemuVer, _ := d.version()
 	if qemuVer != nil && qemuVer.Compare(qemuVer6) >= 0 {
 		qemuMemObjectFormat = "indexed"
 	}
@@ -3160,13 +3154,12 @@ func (d *qemu) addDriveConfig(bootIndexes map[string]int, driveConf deviceConfig
 	isRBDImage := strings.HasPrefix(driveConf.DevPath, device.RBDFormatPrefix)
 
 	// Check supported features.
-	drivers := DriverStatuses()
-	info := drivers[d.Type()].Info
-
 	// Use io_uring over native for added performance (if supported by QEMU and kernel is recent enough).
 	// We've seen issues starting VMs when running with io_ring AIO mode on kernels before 5.13.
+	info := DriverStatuses()[instancetype.VM].Info
 	minVer, _ := version.NewDottedVersion("5.13.0")
-	if shared.StringInSlice(device.DiskIOUring, driveConf.Opts) && shared.StringInSlice("io_uring", info.Features) && d.state.OS.KernelVersion.Compare(minVer) >= 0 {
+	_, ioUring := info.Features["io_uring"]
+	if shared.StringInSlice(device.DiskIOUring, driveConf.Opts) && ioUring && d.state.OS.KernelVersion.Compare(minVer) >= 0 {
 		aioMode = "io_uring"
 	}
 
@@ -3611,12 +3604,21 @@ func (d *qemu) addNetDevConfig(busName string, qemuDev map[string]string, bootIn
 			qemuNetDev := map[string]any{
 				"id":         fmt.Sprintf("%s%s", qemuNetDevIDPrefix, escapedDeviceName),
 				"type":       "tap",
-				"vhost":      true,
+				"vhost":      false, // This is selectively enabled based on QEMU version later.
 				"script":     "no",
 				"downscript": "no",
 				"ifname":     nicName,
 			}
 
+			// vhost-net network accelerator is causing asserts since QEMU 7.2.
+			// Until previous behaviour is restored or we figure out how to pass the veth device using
+			// file descriptors we will just disable the vhost-net accelerator.
+			qemuVer, _ := d.version()
+			vhostMaxVer, _ := version.NewDottedVersion("7.2")
+			if qemuVer != nil && qemuVer.Compare(vhostMaxVer) < 0 {
+				qemuNetDev["vhost"] = true
+			}
+
 			queueCount := configureQueues(len(cpus))
 			if queueCount > 0 {
 				qemuNetDev["queues"] = queueCount
@@ -6882,7 +6884,7 @@ func (d *qemu) devlxdEventSend(eventType string, eventMessage map[string]any) er
 func (d *qemu) Info() instance.Info {
 	data := instance.Info{
 		Name:     "qemu",
-		Features: []string{},
+		Features: make(map[string]any),
 		Type:     instancetype.VM,
 		Error:    fmt.Errorf("Unknown error"),
 	}
@@ -6943,7 +6945,7 @@ func (d *qemu) Info() instance.Info {
 	return data
 }
 
-func (d *qemu) checkFeatures(hostArch int, qemuPath string) ([]string, error) {
+func (d *qemu) checkFeatures(hostArch int, qemuPath string) (map[string]any, error) {
 	monitorPath, err := os.CreateTemp("", "")
 	if err != nil {
 		return nil, err
@@ -7029,7 +7031,7 @@ func (d *qemu) checkFeatures(hostArch int, qemuPath string) ([]string, error) {
 
 	defer monitor.Disconnect()
 
-	var features []string
+	features := make(map[string]any)
 
 	blockDevPath, err := os.CreateTemp("", "")
 	if err != nil {
@@ -7050,7 +7052,7 @@ func (d *qemu) checkFeatures(hostArch int, qemuPath string) ([]string, error) {
 	if err != nil {
 		logger.Debug("Failed adding block device during VM feature check", logger.Ctx{"err": err})
 	} else {
-		features = append(features, "io_uring")
+		features["io_uring"] = struct{}{}
 	}
 
 	// Check CPU hotplug feature.
@@ -7058,12 +7060,23 @@ func (d *qemu) checkFeatures(hostArch int, qemuPath string) ([]string, error) {
 	if err != nil {
 		logger.Debug("Failed querying hotpluggable CPUs during VM feature check", logger.Ctx{"err": err})
 	} else {
-		features = append(features, "cpu_hotplug")
+		features["cpu_hotplug"] = struct{}{}
 	}
 
 	return features, nil
 }
 
+// version returns the QEMU version.
+func (d *qemu) version() (*version.DottedVersion, error) {
+	info := DriverStatuses()[instancetype.VM].Info
+	qemuVer, err := version.NewDottedVersion(info.Version)
+	if err != nil {
+		return nil, fmt.Errorf("Failed parsing QEMU version: %w", err)
+	}
+
+	return qemuVer, nil
+}
+
 func (d *qemu) Metrics(hostInterfaces []net.Interface) (*metrics.MetricSet, error) {
 	if !d.IsRunning() {
 		return nil, ErrInstanceIsStopped
@@ -7337,8 +7350,7 @@ func (d *qemu) setCPUs(count int) error {
 
 func (d *qemu) architectureSupportsCPUHotplug() bool {
 	// Check supported features.
-	drivers := DriverStatuses()
-	info := drivers[d.Type()].Info
-
-	return shared.StringInSlice("cpu_hotplug", info.Features)
+	info := DriverStatuses()[instancetype.VM].Info
+	_, found := info.Features["cpu_hotplug"]
+	return found
 }
diff --git a/lxd/instance/instance_interface.go b/lxd/instance/instance_interface.go
index 6e6ff0de7..2a126ee78 100644
--- a/lxd/instance/instance_interface.go
+++ b/lxd/instance/instance_interface.go
@@ -199,7 +199,7 @@ type Info struct {
 	Version  string            // Version number of a loaded instance driver
 	Error    error             // Whether there is an operational impediment.
 	Type     instancetype.Type // Instance type that the driver provides support for.
-	Features []string          // List of supported features.
+	Features map[string]any    // Map of supported features.
 }
 
 // MigrateArgs represent arguments for instance migration send and receive.
